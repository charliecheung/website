<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Password required</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" type="text/css" href="styles.css" />
        <link rel="stylesheet" type="text/css" href="styles-pwd.css" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 460px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
                margin-top: 100px;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #FBFCFF;
                border-radius: 4px;
                max-width: 460px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(151, 127, 196, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #282D46;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #282D46;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #FBFCFF;
                font-family: 'Helvetica', 'Lato', sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>
    <div class="header">
        <a href="/"><img src="images/profileImage.png" alt="profileImage" /></a>
        <input class="menu-btn" type="checkbox" id="menu-btn" />
        <label class="menu-icon" for="menu-btn"><span class="navicon"></span></label>
        <ul class="menu">
          <li><a href="/" style="color: #282D46;">Work</a></li>
          <li><a href="/play">Play</a></li>
          <li><a href="/about">About</a></li>
          <li><a href="/contact">Contact</a></li>
          <li><a href="https://read.cv/charlicheung" target="_blank">Read.cvâ†—</a></li>
        </ul>
      </div>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Please enter the password to view this case study</p>
                        <p>

</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Submit" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "The password is incorrect",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54daed0fde1838660118e98df026f90784e6d4e7269d8eab58fdb2daee77bd0852b7561411ada1d71cfa6748f8e7c2a174d1c51a8e9f97db364ac6cb728510ff0b350fbff372c8c02acb7bbb4e226a64091e87f533498913ae228fa3ac5358e793d7a7c0f6b5e831266b5c380b8ff71b529aa6d5fa773ac0761950ab4e04f824bbc95628c68a993bdb5817a70eb7c072f7ce96be3a9986a763864e6e9c66331a22e5b3d6db673b98527921d74ede90299b022ad1d6d3bf6fea880548c51f5248509c1fa8f270805cc8041257ee44070350a790fcb48ebafac6ea5ab77d9eccbcab7828bae31edd1483adb0b893a873cfa2468faf54832a5853ad9013a41419b3b98171bd4b221f13ff495bc86a6feb689c50e4e5120a71dd3742c52d688fa67b3956eedf454fed9063db5d9be75020b99b2ffb6e2261993083232373cc5ea8dae7bcbcc414e7d27ceff520313427360d1c168ae3d246173881bfd867cd04fa8b74a831f6c946930e202d17d90a0558d5663fb253b2a4ec1ad435b42a1a4f655a147232ed18461eb660a7208e4b9353910c08ce0a364f86da18189c99cba3897bed5213a526fa95ec1f484cfbc69e6d2c44908eac73ac9d105944c84ec7d7172080a29abcd789b9e248808c5718f66afa7c2a0a849d67787236631832b3e026c7aa59df6ac96a8eac8f0528c365e07ab6e3c53975cd7854015a3df4d200de07c4799c26f6a2aba00199dd436b73124fa64da32a280e5714f5ea332df54195f17f6cb1908a0b231bd5ed6badc90906cdb6a7a789c43c0ecf4877319b414d85bc7faa198462036183f57a66337bdf41a7eb82ceee2327b1ccba7eddcf0686c6b5e018a69488bac683175e0a55e9cd68d6c95a8a155f02a61b7f9e42696617cf9769a3e11a946a2da2aa6f046948ab9bc5b6db74a4d40959094883577443ea94f6cb63cf4fec5ac6a72bc001165ce634f93dbb24287398118094a39911ab2093acb29a7c66976496475d0ee93cc7c5aee14de1d9106bd709591861c2de9c547a7c92bdd19d27a778819e987d94b1427d378d7826f8251c1616f931abcea1eb3c6334265b3296c9ef396719103eb7d5ec7e6e8e574a18b5ae8f972496be0d937e64adc044dcbc93d77da76d053ef323b07f067b944294676b84c2713f362a57e65c9ad53417d5eab15868927f7198b9fc543b742a8270be77afb766e2b401a61f11604171b696b2db5b8a16d0347334ea1b894e097a522f9981c1996ab06383c51585465a39860fac47d70c9e67ad0104c6c2d3372e6760f01a291bb46e41065957d432223c4889b15d407703d68132340802b89e1cf4758bae6ba373b08b937f9c6d6b68535012bcba307008b6ff4d06d63e9553d78dde69af499314021b5f732f746bfc32dae2795410a4b028b0edd6f3f8cdc7854e8c3d80fc33664a22b6b25de1354f23614c6d874792b862aeeb4870a1f57489d151178cdb8ebce2739e5c88bf2f370c70cea33066ec143cbe1106f4fc823faaca02ddc4b5d3fc2241a237ecfb78d81956a3e935d478a7ce830cf14b725f5e256e3ab45ce90527ccc898c364212f2b6b7d45d06f47fef6f0fe1bef58467eb80e64cab26a0d8cb165b90be711ea3a8d495976ca0c2aa138e8cc3fb6dc939675a7859eb99ea964a4269656f4673cfa53273bbb4094e535aebd134c594d4eda4b35b087c04688dd0ccc6d720bf94d2a68f61ff586ee9f99677a2a2f6d80667f6f780797ebbe1e248e7d03bc87604cdf23c7b154424b7fd27c2c607a489664164ac630d6b21c34c571857c25f06827ad5b3d9956cb28ff451a7bc60df749dba93021046986e3a86a7cc3049cde240ad6603de4703113fa2aac8ce61a5a5d69d9529991948207f12bee88f51fb89a2a7da4d884ef662b9e9dca4a21e491b708016f62da278548febd810fb8dabeb3c77f9ab7e97966729ea638ffb1a8f7c3b49c4e7577dc9245ea8cfb82836025f0a71e278a0846b9732ceb1fdcfe4e58a246f1aa0cefb095a4f596ff097f6a39d61163cc96116ebb203608a7b405231beec9da44c625bd666a118cdfb45e4b503ab2803893d994236a5f863c7b96c333065e22e83bf1bfd0a10db59227871f4686f81fea175958d5ab21df7dd88f061e231190e38162d30b4ede39857554d2d09aaf53e06883dcee52f9d7f52a4377af7bb333bb1562ad151db4753800d686202da0b990051531739bda26ffeca1c408d71c77fedfc4e3f0bf66edb251725442b56b164f81d0c8a640af45dc0e1075ccd10fc9724d5eb298249d45d06053104bdacb65e74ce04b4f6c34d8da5ff29e4c5666c8a2d7b0a250f1ce95e5db9deea7e0ed89dced3c5355a04d2c0c61c45d1d9fe7f4fba94c6d2b1fd16443f09b058601149e3a1dca3e0248154891d7953f96b96ba1a84fe5337cd8869542cc843a1a24a50180857478f2882b9fb2797b35d077b17dc78e16bbd90c6d92af9e85fa34028a87cab21a9c4e47d05dda3a9a8455e405aabef2af1c1db0b560a36da89aefff6ed55d0289d67cd8ace43589ecdb502b69c73a0e16a97e8c6baa3310b0219b0cc7313e6a277997076a209863b077c3b96be668031a77d16a77e89b6823908cd8c4e3bf6649b56e77debd98b51d20bc93cbe3e1e2e415deb0ab4a38364fa15089d2a88c59556e0b5938419cf0590c9710f55b9d80e8d58da7d53f98541d85393ab6ae366f87cc42ce0698167be2e90765f957887d22e1f1db12185bbcd7fe7c42cab31d11a75afa026aacc41213ebf7fa352f3472e13a05856f3e7572e8cde8b6365d54df3cacf88cb2f8b67fe8d1fea06bae879fe8ff0035943bde1bb63a050cb0c9b11fff3b6dfde870a522edf5d880f4df057d6b29c1eb5919870de03a09d23f439080f977c2562420e2ceea359e517722c8aad0e7ad07f581a3e7ae63114d3f15cf17ef762bf188369b33f89a1b74b46a708980088166b6acee2843da701a33c3b054b4353645244d71b37d7ec614a6dff3f7753dc12dbfd8275b6e4de32b6d0a46c7693b6bc8bcccd5f193c1c9fd5a31f46fa57d109aeffa785d8654dd98cf3a801cecd592c4fe35e2427372249885b390f3cfc47bd592f927e136b06a4572620f12d85aa8a6e09b30084e7cb494badadfd5f7022bd0639a287806d778bb8718044a0f9459df1db3b9ab0e25d84762d527523a512e40480c5e9ede0614776111c601736abc02f5ff13a0212161aea3aa7c636ff735868542569ee0f21a83a34256bf94fcfb2f607a5d625f850624f9605f42ce17fd6969ceb762026694f4392098fca140c28b704e8a54cf7059342d0855cb71821134859a289663216ebc828eebaa7c251e8fafb63c0b00e5530f26936fcc018cce9c5b83149e5b298f2017d1c4ab614179ccf8e9cce8a81bc17041a87eb42715f37a87957f5854c16ca71663ba822d8e1dac17138b89603cab14b43ba76417565466f8cd66affc5ea3f66040d9465e11043c8c92c8b3610b24ae0d81c0caf04cb4e52e0d1313c265db16d76bfa0443e503cc49d8a02a95953558aa25dd133bd0138aeaf11bda5dbf68792ec3e51ba53612ab0e7c64cfaf22253a7c477f6b72461b7c52a31a70b98e98392d85e0348e02532592d927dd9e334e5f4f916844ad51702236536d9ce81660d8d3ca4d033f8dd12d1326f6985c7b7f57f4d2ed6f1188f83a89358c045a0884772956acd2a859657dddab29c3839848e9609f7d84501f51fe4dae3089bf59ea2cd049fe4477e010dac4b33e5c027cd92dc54abba1e452d5a2d554d0d744f942fa593b39dce73832c1ff382ab12ab281cef08cf59b3607984177d7f891d09e973a52e3635a3f917ce1dda60f120564ace2a8ca8872c6ce64db9eab0395158e4d9f389609e54d2d643f98e54b4f7340b4f320c9e0e66997403f0cea0e7d84f848e26e9179fe513aebf97b84f8831397d993d1677d0f15a9f6e6191d357dc067575e90107d8872796de04128c2a1b740ffd2efd0a41c94be6a7ccab4ed67afd062ecf8ba9dd74640c5b9469caebb8c7d5abc54699a61a05ede199bc2de3b0c89b2ed16e6b7328ebc5782398b5b2df72bcf4611caf6e1b72ef07e9fef5487c0d4d65d57ef1a2e365468e8da438d90bd03ebb07c272fecb9106820b7e2fa3aecd6f03395cf6fb074e19dfa54b6771d830505282a1f1fb8e30eda29db0578d20f6d4355a634cc9cc642f624c3f93506108c87f5691727882e64dd70a11f34fd91623acaccf05e7ed7a0f68b37c4c1f99aa7419d83f9fe43d66c754220313b28f2ca7e396f2caa86075bb139516df451d6b8a8f2ec748ef68a08ab736ac9e61c702a1a26cab0528c8cee792283b900b54c4e9cf146dee5d65908b571780d3189b4e4c4784fa57049dbc10f3c080057751979acfb029e4fff3fa36d8e2cc16b5b8398030e8025184ae7d9bd969effa2e1a049820a68a5b3f84169e7599bc862d63a8ab2026ede9bffec802d36f8a18df75e04bde7d860d71cec6505c43f011da086c393e869821e5aa27338c4031c352ff0dd2a513982ca0938984e88ae1930852f9f47024518d28e5c06a13009d06ae564cc9d191fe62334637890cee8a5910a6d9913337ec260d30c4a658d0939e71f921cb16c717d491dbc69205224184fe8a0486716885cf597b789b4028f9df8b718492c534ff01ffffb32a392e9e1a932b1274155d10eda4842c0c3192c99f4d5f93c000836d59406f4d5e7ad827d42d012dbbe9a05dc6126df1c9d46ceb2b693f2bb6a1b0b345bf0394f8fb43aca2c53dbf4b13c418e1542dcd91d6a316bf3b68f8db653dec2aef005aa7bea8c4b239698018e543612f6de5a3d9b6bc41bfa7e1401537add84e2001da96d04128cf8870002636932695a896108a0adedcb5478fdc22ed0e47d5e5f1fc628174c340a4c26809a0dbaa16c8462c85a409c079f426e6cb7a3f29538e8f5566fad8ec3875efb6463ca3ea81d2329c3c365905aa8d25612a31ef7f1917fc136a3e99e2f296001eb9d68963fc90533a2de232c6f4821edc766ae89feec257ae97295756f1fc7028817a7410c0c7f72acc30df3a5dfa4709845f251b3d2a1f4b6626dea7099ce2819732e84ea6c76df80027c71164d3046185bc1c8da51016d33b3247d4fbf594d478bc3092052f12909af960bcea2a6a43d9900aaf3026e369fd93abde37c47bdcb3d08f122eb2d5808e9d20d59ee03d9975b2817cf95614c66b3073266e01c4fd5fcf12edf277e915cbcde042e5c97176dfaa3d9cdfd3fd6c756666c7bcfdd873d7e26efcc6926a9477ea44e585d608b09542f66b220770e12fc072a3fe02dc6794198d9b502485e65513c314691d8701261f105db7245ae16b611266a86f85f8cd64bc04f30eefde21000819a0d9d1ae2ebad73d51a0c01964b493d7d8eb9db688f58c744e4a470d0ee09a2bc7776416e4a21e7a3c9e7b2085856268bbc216f6a94a99a675fa85e24a1b953c31cbb2ff22677bf6ed596b26ebf687bd805d1db45a0d2d35b1c247124930290709c8230a3aa5ebdb0ba844be3da911effcf03e2fca3b967e17069c423adbdedf3273e50aed61296b1267bdf8683ba2f9482c373fb98299c0e6899163f9b098bd7077e4f7b829729b6a88eb93e0e93e6569fccda25842c717e0ec215bc7dec9f263715c7a51fae29ca218b0c53aeaaa0cb59c58f1102b6f5d4728bd62d4c19d70ced1411950c0cf0ae53b60f8a9cb29487c45b98012252c2c4266152c65b982d6e71d743bd2b8337fa2d4714a1a2f411df68866ed0e831a2267be10a769b282d4025ad3c3927effaf3b075d01e8614f3b7e7269ff5b982cc657a9acef6751e6d360fc9ac62431d7821e4c870d38fc5323e11e405e686880b93350791264fa0fcfa80501be594e27f6ab0eaaa390ebcc3ce8112df49aa2fe0a3fcfa910f9a626da21556eb1758beaaa23dbe6a773ef1ba3cf1b2583a3c1233d8df024d650cca38d712cf2388646b1747df89067774264e1637be133c953169835f7bb01a3a93aaddeebbd4e4737f6065ba0326932c88e779854a4422fd7f2dade046abc19542a90819196344f9f97b3edf5779af9deb7595cc9d3c52acab70bac0d3bca8552a09dc7168e2e98499881f8893ff644fcf9f76ac0efd69862956137b75dd5ed82d96b1290d420339d67cf955268653958de429e0e5b5f555072bbe92efc23a8df201db00a26ada4ea9340c6d1689eaa12b1893b726b512a613e1396b7e551d80cd84efb297d2234039c895dad92a0bf6b90c6a4a13a08d1362ac8891bf49566bcf6c40e72df66aff9ac8488006df14d1cd251301f4e568d16853fb806cb696bfc755e15d760000d9107223a1ac18d0aefaffc5a2499344e71afc0414902e12a3411a7430bcb21d101569586ceebead735f6b1e53333effe784f7ac20c7f45317e3c17dfce10a8c4687969baf2e3f5afc48896e3087eaf9d14ecd0cac4e11af15d8961d54450d64739146ec20836a47dfbe90f32ef671609df334c2fb052cb6de1e0d884b7c5fc979ef5322cf73f228ad86d494d41d5f4b69cfed6122906b63b68e13077bca6f5a4f6902763e9ee8fd5389562fdff74b6b1f833be14facbb6588563df6b95bf7483f771d8536aad1434bdb11431209ef3dba199153b89eae8aeea651c1db6bcb8028e2f88a7ab8dd9ec6359b2b15a7b5ec17e974521531edba07662ee5919a66623e697aa10f8a0f0b0a3eb10af56620fe13b0dc665b2ad6b144500f4995f4ccc10358739e0200f56f07742b6c1081ee42654aa1a05b7bffb23628512cf8ffe987f9d46b6ecc042c0680d6c3557f8c456c99a825411f226c66cfbd82b86baba59aa0622241ead0b897ee766bbacd54d9995d3fff3aae4a492cfaaea88757e39085080f914d61b4a04710f804df1f2785d6b2c6868346d342ab279c99d77d77b953e6099e89e9c23dfd95a032bc550bd9884a97fbf1a6372fffca3ad3214ceed2ee885a6fe26de583d0790505054bd8d46087c1318be87f4a5e80a0c7ad06663b3adff05d2e5963eec89647c0b4841aafb2adfeec7e9651441ee26fbc8cd7fb96af6bab8ed3c7dc20663f978e4b3e28222c14587167bcc635ecb5faf163292399980709d1ddf44b1a8d5e4bd17dd17c748bf8cadcdc58416d0cf9251afb27680ea2c0540a9f6bb94dfd9a7c5c3e966b3825530ec0ce27fc9b8370ae68e51f74797aa35130ec1ae08ea88ae7432acf4b621f8a0aa696514f08b2deb233d421d5a79af75e60408ab64b7bf19b4b0c56251268a2bfe4d4904867a03a2f24d8921191fc25e015407ba83e3c6a4730229a50f52354ace40ade367cb37357d906239d7d42b26bde92f3ac8eb534a500de8dcdf57b4769b70e1710dff21eddac136c18ba4b9ba7523ce8451ae5b3b681dcd5a64c5d853743f31ab17161bfbc5a7564f9855f167782513d20df616952de2986f471769f63894f93be38c0fe5d28e0babcad6e88570241d9a59d2e7869ab9b18be8bdbe58039639d0bd28cd5354de54e248b00d2c5c5016599beef370789110c55fa55e9cff0b743f4e362e56c92cb55e0feed2c688dd20cce13ca9d965dba1fbcbfb0e6c5b95e08213109f8cf337fccc94c54c90007dfc8c417ce27a13f4ac06bfc66a0bb4bd5824ba2ae20c85f9f0bc2d4249c074ac6bf094a69e66680d6a53b40bc53df4383777157df42e2550371af69713f8de68792d002924dadb8b5bd79ebb8780b88a17e1d4b22cb82179e35fc2f6c3289cea0b5f18709fe83cf6f69b1a8bf1182c81a158adc8949e5acb0d261062b631bb530a5a328d6febd7d093cd81ca30f8bade0490b2b5531ddf3aed6bd7e4957cd510f557946b7d7a63f7e1905bfaec3645547cf34eb0faadfa3c063e60f25bf6a32dd2b1d47a0c2ca9316e60079e35bc8cebd54dc32b55e9a3878fa98ea86d379d00a66a6f3f432fedb2ac9b231e817812bb05ab0c684d6df2a171b9e561949fb9ad961f93930dc790f42271487102928e0ee4c8f430ae08eec3c907b895ab29b96739c86322302cf2d6182031911b2f2708b9baba7a564f86422d13d1179cef173e25e9818a1eb491501df539a023a3f7e1f8179c0d545f4be3a88232295ec130310594a3a0eac786b4d3b7e426e6629eb108bc0fc530f3bd6b75110eb99ea4e20a9e8af437ab8430753c730ee211659589806d9df76eaa9030af9a9226d65c373f1c0bdcf81c64a91f48af7aca73844411b01a82677e7cb32961bab5b14ca4c6a302f44b1c5860f04eaa2c9b6f0d395d5e12ea3299371bfe6805b9e6dc2f69f9541cbf76e2229a50c237517db54699751e92822efcdc9984871518613713b0b9fd23368acc7979224a707df1099d22aae706907ffeb48119c0d11fff847817b121c74cb58cdb6a1444b9c94b547838d0b4616c4701a0e221c248c5ab90b62d2316ec07251bddf3fe0089436266a92dd62014cc88036099f38eab9894dbea9968befd9155c3a9e29c4d3d6d0bdc4fcb23802c919b8131da1ef9ebe7191d40b807775ed259bf35ca2af31067582ce9784f9def23ad2fd1b0e1da70b136f7b2d2190cee74f1287262d13e362bf9531ec52c0e9f19b2b9fb912f56b19890b57583fdaf903b215f0258ce59d8b11ebb147ae69cad29c21fccc4cf22019934a5b794ea23ec5ab273258ed2c1a56607931b4a1a95d580ea3fa7dd0ef12a59e1ca841daca504b37ac1de6139ebfa4f60d43a5f52908a842a0d3bbe88ec9772c05d7dfdf16bf8f0e5b11991b368b0871731dd043a0e7dc0869fb1954ba494af02f412f681611274c9af1af6dedd37323533a70fda7227e1f21e3b526e1445ce240c52689b24db2e725e7dc739c6c1b35421a8f33b9bbe0e61faa451707d9b4e136ad26ff3145fd8addbee3c8333a37977689dc1e6e677f78a5b5ebfaed722fe82a98eef37750200995590fda9a02bfcd7966ae6894cf30ff48a9f872cf2359629129f6e014b9499efc4fb1523ff220914d41842774c05a3b2812685b3f82fd3a0adbaf7458fe39647be43b79d3f605858a921fe961e6ceb6725d02fc4934b83e74c1c00616ac3e8863ca12c0662414dc6841aeb583343c185b7082c5b0169ce309ab92fad51b0819d6f77adbe55aebac5a66e0af8cc2c3dae2ef7b950796999c9d98c624e2ac6c25a1aedfedbb441b7a5b50d05adef7bbc6c46438a14cd87e185f1e0a02f3722bce2fe2ea69474c3e2cea106059cd25106d1bb7dc2c445258750e6a8714e056e3054fe9002b8ae182a0c6c8bfec07fd16a115127ffcc37d5846ecd3ad351a469cc9fc67c387b2981c4935b8def4e12c2f5b704459fe50b86796c8d51aed2d4c3796d400583dea002bf757575c5af0643307f91d0a4bf39f1c77f32fb6314ab9e276805dfd4d641d4e34a60862777d472ca40c4010177c643a876e400f9755d2d0df25dbe446432abdfffe9292ccab6a32c5c8cc7269ba5f87abe022073ea07e7f2762360d99214f81de40c2e342630e53ab76baea76780bdb48017f3ac1b7bf62303e543c6bba4454aca61d9229d151df9d1432dd1ee4268ef0407adbaaa1d669ad490d69124cc5d315613823828a5600103952f3ccb2109c7508b5c32d3bb72cf982c8960f56a1f439219d75e88fbec01a0c6c9944ea3c50c799f7d9465574d70720f6fdba17f99c279cccafe2d071f43c2f42dfa73e23aefffc1dcdea2fb2b2044eeb2425322ce62bf947dee1b53964418e8ca86215714de8982645806325d446d7c4af80a2e4424413a96f0db305705ea0d341cf0918eb11eb6c5b4a74570290420de1ac9cdc41091b0fc0e05fcf7ce06d656790d723c7d9233ebfc6b1eb8d1226675ce88af9ed481e34e6553d490d1562ecc5516ba33e968f191f1ba312240faf83389cfa26bc49dce03183486458a51aee524df929df6d09985cb23b11fba32e3a588bc5aa12d840479e6ab134108984821c1a395b71cf686dfb273bf9d9700637ecc6cf2dcfc60f3cca05b5110d4441ee40238dd8f0479fe59a128e9ebf62434b650da7b73451e192040392139ef655bfcdc9e718f15f444353b5c6204c1a51169a7887809136b048b7ecbc962b26be809ac850f1e7a3f053b06b9981a298e49dc44e69d909969c432bbe2aabfc42215c41b1d53cb936e47dccd6d1b7e8ac6a45d7d32475876fae7b6fd4849aa377dd411e7de0bcaeb07de1d0fd3eefcb008ba5d3d30d7d27b0e3c457ebad24d4fdf5da77bdc3f8b2d1bb3c2d4e7bc23d100a4c92f565e3850d4385360e67c2a5c6842e16e58cc9c271370864961aa78a6a679ecbc769049b4e76e85ff169530207962cc7c093005cdc9fb95d193c743cdf85347205b0256467790258ea8c9592ba94b2b68f5c17760c843adead22c5dcac4e8ca0a9c397ea312f1b7cef1ad4b63fe591c14c1771f14362e102ffc5fd527f21a6abbf1070e064430c4a3205b86e2db10e3036540143997bf4775a9dca2a9ca29c4afcc2e7909e13b9775ef557fd0a29ead4f1981e5084f0ea2f64c9eb3cd1fa03a6cf1c7781ab4f29f4b63762d57bc320f874ad7255a260db951d7a09a25073b8307cf0b8551394838ed6d3c56769e6649bbca0ca420dd0c6c69a5cdf2ff536548550dcea9f3c70b67958fafd5cfd726901acfeb4df1acb5d6cb1b5bbeefc8d458753f0aeda8e3f17ed23b0ead97b8e9f3a9e6f75efdf2fbdcea814f335c7aae700e8617a1b25b699e8839918c25dd639141df1196406e2e30cdcd217265fcaa158485260640db3b3ca53c64164ef38164c6a947796cab6c70b3624b857467af2defa6419992e949da5b9980657fded1ec38f44e2a32d0bd7d57a4ce098fe477399c50058f4b22fdeab31bcfa5266b4e922ab607415a5709504350001b740eefdbf2ed91aa4852e3be811c6113ebbb3e09ee27919ace3f81c50a0ebabe4ae37efd30f359b5d68cef3f39ee08d9c79f6a528d781d00cd6f165f1d3b91866ed055c0f6c5063634feea242d169c5c1e948f0fe9307e338900dd06dfab7318d882ed7b76bbc0b158ed7f8e3ed49e9624813240bf62beff49d4cb4c94d7ffb6afca090c626119ce57219a69712c9da4706c169196ea8733d1507973c60b660f012700410916096521e0c5e63311e20131bbe5adc12dc43898e48b4f27e4e9b61ec6e591983e4f54fc85e517f126de443d86b3677fdbe622ff98166cf4c63d32baf0346065b0a7687cc3aa86421f0e63fdf6042addca2391055ee2070de8d5bec55a8b37b28fcf31bb8533d41561d2eef1a27397a8bb074a7a45abbe6142918fd95d9af75c5be4d367a30e2ab289d1b0c23c49a28ce2eaafb93c975ce243964638a6b6ac13fc77466a0a0a6fa0a2ad3d714e0d9bb5713a316701a36cb494191f60332a630331bd321cdc1aa1b13106f1b820ca60a31a59764262b61fe08f9312f586791f17d6d7294b17f3e8bc3c6878e03fd51b42c900b6cd86fe6ee3379062f4972e67eeff56b77d655cea0c3267ac57e03958291376f2b8a225479dfbe8db47a7e173ca922e84a95a54942042b22e1f823ed6f56e5f729af4eed144211e63ad07d5a3dc4a903f13c3dcc437999bccf7bbbaf06411ccaf1683e97b375b02f9e3b3bf752cb9dcc5e1d8a0006b4f51b5e4fbebbc70c34cde83bdfee63b033ddbcaad954c35eb54a61317de435b62305bd4c1b4db941e086e7d22791fce2409358e4a0499dae093a7b315cebb652807086390f5478d8d67b931afcf3c1013824a24d865e84717c2207ebee6948aa60faf39973cd93cb4970463a694b4d98bd6e9181c13233e140b11c78c35347d02913fcac62c433989fd0f43734886dc09cc06b83f456d4b58c8c7a5beca91ea30d4e9db7b87f21a9603f4de2d7285ab661d7c1e752b96a01d75d3fcf212176a1269f7e9268639652477992273b1015a3d27e3784a41f3e7e30841d2f8c4f07652a585eca533525765a194ebdb250ae853db56be01aad8df650ef961d1068868f067310ddbd83d25e1afc9890de650f6e43a74a3f8fc05328f53fd0bb326a11e65bbfd0640b81d3a1ec236077dbe98813b1213760e64a3f3635aaf83d6eab8205ef368e869a88bf8d9d2b257bcb8dadaeb1c8de65198cad4301bbd5588869b1b859c9a111abf959e5836c577b000f1ea412fa75c42f0e4b56c66ffde68548d3d692c6a4ff086932865df8e61499a4d28bb5e6d23e25bb57e98c1bb1a9a76d160e1b55456c197d50639f36ea95f67892217954e40d0974b0547330b3f3965d95546b97bc85a53b885cdbb7d4ad2d88bc52826e2b67af43b718745a07373a2f12062c823a40c07d9ae6c833b97b192d43ef1542a75f21e68dcf7ff7eea1a8b7fe8a8ed4f5284835a9189aa6ff0ff11b39334344c74157b391f1d650b28b24e7078df28809dc93050dc172be6b9dce0c0d471ede00371612f75546b7b11622da4212fd15da420a001caa0006849b18e718ffd9451680f160a713e6be71a9c0c666eef6ce1c8619a7f5dfcb6c772ee2f5fa5efaa4babae0d76a17073b924e7baf56fc368b04e1191767db6d15bbaf71e3e67b0c938ecf75801d8b90319d1e1de322db094d8aac6a366e9805dedfd46c2adf7843b7b36f7b3ead6f540128a3a95da85b6879032d931f47aca7d2bfc4bd96fe64ac23904951c19bcd1f74e4359f5a0496d662c6ef83aae0f4d420cf0c24fb360bc76ce34cc6b6d9836b23d1f22444846e41625568b82b827579fea36135c14c9279a617b98ee021fc680d3342b27929d5efa8f7677b890b0f55e95ecaaf3109cf288a1f0653a135badd8c20ab668d4a356bb1dbfe971c1f69cf79856fe8c0922758c2ff749b07b2118980602942148d74b1da60f7ea46ab74a5b8ccd1a46a8329856c8875aeeafa0ed4492193ba541504dd5adedae5b6854e76a391830ec092b189ad6881b60fbdb99c82d33c3162bc92d8cd501bada74ba806136ed5236a340eed71d0f90190fe0fcc61f2a639cbf65bff8641ee2b5ba2bd2326b95b33fb06c90c3250bac426b8c7b63cd8632bd38df2cc8e31dea1f2a03fbb230ce6e6fe1e8f500b470a9cfa28683607c14ff1a37edbec90f4a5ca25d853f2998bc6daf7f150aa6fac4c4f0b7e229d176349e05550b2877fe3c3a2c4bd77dcc71f6dd56a4de81f3a12b3ffe06f40516689eca48bc7de818b6eeebabfa409842b2642cb6398ac24787d815c0f297939c5fd8db41bf1692948ed440bb57830c79c88bc023398ab58b7cedbb070fe89c8aa1380f9a404e31185579f1146ae12033b26071ea3ec0b6ff246503f31133caedc826c01704c25132080bf8e8abc34887f23891f669897d7595225446f08686e1da6ba9ecfe2eb26b4f12dda0622304cbe6c037daf1e219ff1007b13ebfab0f18a9519172e8b4afbfb13606901a57e1f35890a4f96dd89ee766d9850e5ba1452698e2baa7d5df3d93ba5a97c63eef96ea623b600b84f764947450b3ce424b97b84f404565c808809ac3855f28957a23a8eb24a1add1778b3e5dae1cf17097c5e62ac9c289d91becccae856ceedd62149675f75e7e719942cee05c87e12fd129d1b4b6acbed846c782af6ab90e402419accabf44acd459704d70648788efc0824c686f7af75c60988a18c3130086246062cc9c6a9b9552fe66f60b91796244d981aaa1a966d14663f0b41d0c6fa423235c7dd34677ed51de3c1994266974118a0905ea133a9f6552067ced3a5d74192962272fe9147e93506e28dba8bc47dc9026152f5e2600ec6847a080324db17c23ff4a4612079ce9d79e4d71613cd00c460443dd7617e84eb07039b2e5e652cabecb2683df48879ae90d53ab8309547ecc561d5f057a11f10a14baca06e50f2912de1a70a02b7edec4fd16fe3172002a43dde6533b680bcae7e9997e0996381ffda052e6c4ed8edc943eb9ae5ca4005bfe1fa9d6113219ba634250f82a0eb0c622c24037732242e1e08fcc765afdd92c8bdf01a7c3ffff6bec90389907a54be3c32ebfac6a5a61c73023d1c1deff794689bbd58a00b47d34865","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"487dc7d710fb982d84af7294df4010b5"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
